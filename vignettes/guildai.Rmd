---
title: "guildai"
---

<!-- An article of the same name as the pkg is picked up by pkgdown as a special "Getting Started " guide. -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  root.dir = local({
    root <- tempfile("guildai-intro-sample-project-")
    dir.create(root)
    dir.create(file.path(root, ".guild"))
    root
  })
)
```

```{r setup}
library(guildai)
```

<!-- badges: start -->

[![R-CMD-check](https://github.com/t-kalinowski/guildai-r/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/t-kalinowski/guildai-r/actions/workflows/R-CMD-check.yaml)

<!-- badges: end -->

<!-- a nice screenshot image here-->

*guildai* provides a suite of tools for tracking, visualizing, and
managing machine learning experiments. The {guildai} R package is a
successor to the {tfruns} package.

-   Track the hyperparameters, metrics, output, and source code of every
    training run.

-   Compare hyperparmaeters and metrics across runs to find the best
    performing model.

-   No changes to source code required.

# Installation

The R package provides an interface to [Guild AI
Core](https://guild.ai/). The R package will automatically download and
install Guild AI Core on first use, or you can call `install_guild()`
directly to customize the installation.

``` r
# install.packages("guildai")
if(!requireNamespace("remotes"))
  install.packages("remotes", repos = "https://cran.rstudio.com")
remotes::install_github("t-kalinowski/guildai-r")
guildai::install_guild()
```

# Launch a Run

Guild AI can be used with any machine learning framework, or no
framework at all. [See here](examples) for examples demonstrating how to
use guild with common machine learning frameworks, including xgboost,
tensorFlow and keras, torch, and tidymodels.

In this introductory example, we'll start by showing guild with no
framework at all, on a very simple (and somewhat contrivied) example.

Lets say we have an R script named `"train.R"` where we are fitting a
smoother line, like so:

```{r, echo = FALSE}
txt <- 
'model <- loess(dist ~ speed, data = cars)

plot(dist ~ speed, data = cars)
lines(x = 3:30, y = predict(model, 3:30), col = "blue")
'
writeLines(txt, "train.R")
```

```{r, file = "train.R"}
```

To train a model with guildai, use the `guild_run()` function in place
of the `source()` function to execute your R script. For example:

```{r}
guild_run("train.R")
```

This will launch a new R process in an isolated run directory using the
provided script. By default, the output stream from the run will be
shown at the R console (the same output stream you would see with
`source("train.R", echo = TRUE)` in the R console, or `R --file=train.R`
in the terminal).

# View Runs

## In an Interactive Application

Call `guild_view()` to launch the *Guild View* application, which you
can use to visualize and manage your runs. You can use it to search,
filter, visualize, compare run source code and output, and more! It also
bundles TensorBoard as an additional visualization tool for viewing
runs.

``` r
guild_view()
```

![](guild-view-screenshot.png)

## In R

Retrieve a data frame with run information in R using `runs_info()`:

```{r}
run <- runs_info()
tibble::glimpse(run)
```

`runs_info()` returns a data frame with information about runs, one row
per run. In this introduction so far, we've only launched 1 run, so so
`runs_info()` returns a 1-row data frame.

`runs_info()` supports a rich set of filter options that can be
conveniently supplied. For example:

```{r, eval = FALSE}
ls_runs(1)            # get the most recent run
ls_runs(error = TRUE) # get only runs that returned an error
```

See `?runs_info()` for more information.

## In the Filesystem

`guild_view()` and `runs_info()` provide two convenient ways to gather
and present the information from runs. Importantly however, the run
directories themselves are easily accessible. There you'll find any
files, plots, logs, or other output generated by a run. The run
directory also contains additional metadata about the runs that guild
recorded under the ".guild" folder. There you'll find plain text (yaml)
files with information like the starting random seed, environment
variables, information about the package versions, and other metadata
frequently useful for reproducability.

```{r}
fs::dir_tree(run$dir[1], all = TRUE)
```

# Flags

Flags are a form of run inputs, or paramaterization. `guild_run()` can
modify flags when launching runs, and `guild_view()` and `runs_info()`
make it easy to compare flags across runs. Any scalar literal assigned
at the top level of a run script is automatically identified as a
*flag*.

To illustrate, we'll modify our script "train.R" to use the `span` and
`family` arguments to the `loess()` smoother:.

```{r, echo = FALSE}
txt <- 
'span <- .75
family <- "gaussian"

model <- loess(dist ~ speed, data = cars, 
               span = span, family = family)

plot(dist ~ speed, data = cars)
lines(x = 3:30, y = predict(model, 3:30), col = "blue")
'
writeLines(txt, "train.R")
```

```{r, file = "train.R", eval = FALSE}
```

You can launch a run with different flag values like this:

```{r, eval=FALSE}
guild_run("train.R", flags = list(
  span = 1.5, 
  family = "symmetric"
))
```

`guild_run()` will modify the script file with the requested flag values
when starting the run, as if we had modified them manually. This change
is persistent, and will be visible when inspecting the snapshot of run
sources captured, e.g., with `guild_view()` (or `guild diff`, or
inspecting in the filesystem).

The flags interface is useful for experimentation and hyperparamater
optimization. At it's simplest, you can iterate over the set of flag
values you want and pass them to separate calls of `guild_run()`:

```{r, eval = FALSE}
for (span in c(0.5, 0.75, 1, 1.25))
  guild_run("train.R", list(span = span))
```

You can also pass multiple values for each flag, and guild will
automatically expand the combinations to a grid search. For example,
this will launch 4 training runs, each a unique pairing of flags.

```{r, eval = FALSE}
guild_run("train.R", flags = list(
  span = c(0.5, 0.75),
  family = c("gaussian", "symmetric")
))
```

Another way to launch a batch of runs is to pass a data frame of flags
values, with each row corresponding to a run.

```{r, eval = TRUE}
flags_df <- expand.grid(span = c(0.5, 0.75), 
                        family = c("gaussian", "symmetric"))
flags_df
```

```{r, eval = FALSE}
guild_run("train.R", flags = flags_df)
```

### Retreiving Run Flags

The flags and flag values associated with each runs are returned by
`runs_info()` as a packed dataframe under the `flags` name.

```{r paged.print=FALSE}
runs <- runs_info()
runs$flags
```

# Scalars

The counterpart to run *flags* are run *scalars*. Whereas *flags* are a
a special type of run input that guild can help manage, *scalars* are
special type of run output that guild can help manage.

Any lines printed to stdout matching this pattern are identified as a
scalar:

``` verbatim
key: <numeric>
```

To illustrate, here is "train.R" updated to output a scalar named
`rmse`.

```{r, echo = FALSE}
txt <- 
'span <- .75
family <- "gaussian"

model <- loess(dist ~ speed, data = cars, 
               span = span, family = family)

plot(dist ~ speed, data = cars)
lines(x = 3:30, y = predict(model, 3:30), col = "blue")

rmse <- sqrt(mean(residuals(model)^2))
cat("rmse:", rmse, "\\n")
'
writeLines(txt, "train.R")
```

```{r, file = "train.R", eval = FALSE}
```

We can retrieve scalar results from runs with `runs_info()`:

```{r}
runs_info(1)$scalars
```

Here we see that guild has automatically identified `rmse` as a scalar.

If you are printing values for the same scalar `key` multiple times
during a run (e.g, `loss` during a training loop), then be sure to also
print a `step` scalar in between, to enable guild to track history (and
enable visualization of the run metrics with Guild View and
TensorBoard).

`runs_info()` returns the last observed value for each run scalar key,
but the full history of scalars observed in runs can also be accessed
from R directly via `runs_scalars()`.

If the run produces tfevent records (e.g., via
`keras::callback_tensorboard()` or `tfevents::log_event()`), those are
also automatically identified by guild as run scalars, and included in
`runs_info()` (and `guild_view()`, and TensorBoard and other run views).

# Guild Configuration

Guild accepts a variety of operation configuration options. One
convenient way of supplying them is via hashpipe yaml (`#|`) comments.
Hashpipe comments are always parsed as yaml (because yaml is a superset
of json, json is also valid).

## Operation configuration

Guild options can be supplied as hashpipe yaml in the frontmatter of the
script (in lines 1-n). For example, we can inform guild that guild
should not echo the R expressions in the stdout log by supplying
`echo: no` like this.

``` r
#| echo: no

model <- loess(dist ~ speed, data = cars, 
               span = span, family = family)
```

A comprehensive listing of all the operation configuration options that
can be supplied to guild via script frontmatter can be found
[here](https://my.guild.ai/t/guild-file-reference/197#operation-attributes-6).

## Flag configuration

You can optionally supply additional metadata about individual flags by
placing hashpipe yaml annotations above the flag expression.

### Flag constraints

For example, we can update our "train.R" script to add constraints to
the `span` flag.

```{r, echo = FALSE}
txt <- 
'#| echo: no

#| {min: .3, max: 3}
span <- .75

#| choices: [gaussian, symmetric]
family <- "gaussian"

model <- loess(dist ~ speed, data = cars, 
               span = span, family = family)

plot(dist ~ speed, data = cars)
lines(x = 3:30, y = predict(model, 3:30), col = "blue")

rmse <- sqrt(mean(residuals(model)^2))
cat("rmse:", rmse, "\\n")
'
writeLines(txt, "train.R")
```

```{r, file = "train.R", eval = FALSE}
```

Now if you attempt to launch the run with a flag value that's outside
the constraints defined, guild will throw an error:

```{r}
guild_run("trian.R", flags = list(span = 99))
```

### Flag destinations

As a project grows, it can be helpful to be able to move flag
definitions out of the main R script. To do so, you can include a
`flags-dest` in the frontmatter of the R script, specifying the file
where guild should read and update the flag values. Then you can read in
the flag values in the main R script using `source()` or similar.

``` r
#| flags-dest: ./flags.R

FLAGS <- envir::include("flags.R", new.env())

model <- loess(dist ~ speed, data = cars, 
               span = FLAGS$span, 
               family = FLAGS$family)
```

YAML files are also supported as a flags destination:

``` r
#| flags-dest: ./flags.yml

FLAGS <- yaml::read_yaml("flags.yml")

model <- loess(dist ~ speed, data = cars, 
               span = FLAGS$span, 
               family = FLAGS$family)
```

# Hyperparameter Optimization

The combination of flags with constraints and scalars make it possible
to use a hyperparamater optimizer with guild. Here, *flags* are the
hyperamaters, *flag constraints* define the hyperparameter search space,
and a *scalar* is the objective to minimize or maximize.

To illustrate, here is an example run R script:

```{r, echo = FALSE}
txt <- 
'#| echo: no

#| {min: .3, max: 3}
span <- .75

#| choices: [gaussian, symmetric]
family <- "gaussian"

model <- loess(dist ~ speed, data = cars, 
               span = span, family = family)

plot(dist ~ speed, data = cars)
lines(x = 3:30, y = predict(model, 3:30), col = "blue")

rmse <- sqrt(mean(residuals(model)^2))
cat("rmse:", rmse, "\\n")
'
writeLines(txt, "train.R")
```

```{r, file = "train.R", eval = FALSE}
```

You can use an optimizer with this operation like so:

```{r}
guild_run("train.R", 
          optimizer = "bayesian", 
          minimize = "rmse", 
          max_trials = 10)
```

## Managing runs

Guild comes with a family of functions for managing runs.

-   Annotate runs: `runs_comment()`, `runs_mark()` and `runs_tag()`.
-   Move, archive, or copy runs: `runs_export()` and `runs_import()`.
-   Delete runs: `runs_delete()` `runs_purge()` `runs_restore()`.

The `runs_*` family of functions all take `runs` as a first argument,
and can be composed with `%>%`. For example, lets investegate the
results from the last 10 hyperparameter optimization runs:

```{r paged.print=FALSE}
library(dplyr)

best <- runs_info(10) %>%
  slice_max(scalars$rmse)

best

best %>%
  runs_tag("best") %>%
  runs_export("./best-runs")
```

```{r, include = FALSE}
unlink("./best-runs", recursive = TRUE)
```

The `runs` arguments can be supplied as data frame, as returned by
`runs_info()` or `runs_scalars()`, like in the example above. `runs` can
also be a character vector, with a flexible syntax supported for
specifying runs selections: For example, `runs` can be an `id`, an
integer (the n-th last run), or any combination of filter specifications
like `running = TRUE` and `started  = 'last hour'`. See `?runs_info()`
for details.

## Using guild from the terminal

`guild` can also be used directly from the terminal. Call the R function
`install_guild_cli()` to place the `guild` executable installed by
`guildai::install_guild()` on your PATH:

``` r
export_guild_cli(dest = "~/bin")
```

Then you can launch runs and perform other guild operations from the
terminal:

``` bash
guild run train.R
guild run train.R batch_size='[32,64]'
```

As you move between the terminal and the R console, almost all of the
same syntax supported from the terminal can be used from R by passing
strings to the respective R functions.

By default, R character vectors supplied to `...` throughout most R
functions are quoted for the system shell and passed through to guild.
This enables usage like:

``` r
guild_run("train.R", "batch_size=[32,64]")
```

There are some additional conveniences provided for passing through
command line options from R.

-   Use `I()` to avoid quoting a string for the shell, allowing you to
    pass through multiple arguments in a single string.
-   For arguments that take values, you can pass them from R as named
    arguments or named objects.
-   Named arguments are automatically translated from R conventions to
    shell conventions:
    -   `_` in a argument name is converted to `-`, and a `--` prefix is
        automatically added, so `batch_comment = "foo"` becomes
        `--batch_comment 'foo'`.
    -   boolean values are understood to be switches, so
        `running = TRUE` is translated to `--running`,
        while`running = FALSE` is translated to`--not-running`.
    -   names vectors are automatically recycled for the shell, so
        `tag = c("a", "b" "c")` becomes `--tag a --tag b --tag c`.
    -   A single leading `.` in an argument name is treated as a short
        option name, e.g., `.Fs = "last hour"` becomes `-Fs 'last hour'`
    -   Nested lists are recursively flattened into a single character
        vector

Here are a few different R expressions that invoke `guild` with
identical system calls.

``` r
runs_info(marked = TRUE, started = 'last hour')
runs_info("--marked", "--started" = "last hour")
runs_info("--marked", c("--started", "last hour"))
runs_info("--marked", c("--started" = "last hour"))
runs_info(c("--marked", "--started", "last hour"))
runs_info(I("--marked --started 'last hour'"))
runs_info(I("-Fm -Fs 'last hour'"))
runs_info(.Fm = TRUE, .Fs = 'last hour')
runs_info("-Fm", "-Fs" = "last hour")
```

### Addin

The **guildai** package installs an RStudio IDE addin which provides
quick access to frequently used functions from the Addins menu:

Note that you can use **Tools** -\> **Modify Keyboard Shortcuts** within
RStudio to assign a keyboard shortcut to one or more of the addin
commands.

### Background Training

Since training runs can become quite lengthy, it's often useful to run
them in the background in order to keep the R console free for other
work. In the RStudio IDE, `guild_run()` automatically launches runs as
background jobs.
