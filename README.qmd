---
title: "R interface to Guild AI"
execute:
  freeze: true
editor:
  markdown:
    wrap: 72
format: gfm
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  fig.path = "man/figures/README-",
  out.width = "100%",
  paged.print=FALSE # this seemingly doesn't do anything
)

library(dplyr, warn.conflicts = FALSE)
library(guildai)


if(!interactive()) unlink(".guild", recursive = TRUE)

Sys.setenv(PATH = paste0(R.home("bin"), ":", Sys.getenv("PATH")))
for(v in c("VIRTUAL_ENV", "PYTHONHOME", "PYTHONPATH", "GUILD_HOME"))
  Sys.unsetenv(v)
Sys.setenv("RETICULATE_PYTHON" = "~/.virtualenvs/r-tensorflow/bin/python")
Sys.setenv("TF_CPP_MIN_LOG_LEVEL" = "3")


# help knitr capture stdout
guild_run <- function(..., flags = NULL, echo = TRUE) {
  out <- guildai::guild_run(..., flags = flags, stdout = echo, stderr = echo)
  if(is.character(out)) writeLines(out)
  invisible(out)
}
# Sys.setenv("GUILD_HOME" = normalizePath(file.path(getwd(), ".guild"),

```

# guildai

<!-- badges: start -->

[![R-CMD-check](https://github.com/t-kalinowski/guildai-r/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/t-kalinowski/guildai-r/actions/workflows/R-CMD-check.yaml)

<!-- badges: end -->

<!-- a nice screenshot image here-->

*guildai* provides a suite of tools for tracking, visualizing, and
managing training runs and experiments. The {guildai} R package is a
successor to the {tfruns} package.

-   Track the hyperparameters, metrics, output, and source code of every
    training run.

-   Compare hyperparmaeters and metrics across runs to find the best
    performing model.

-   Automatically generate reports to visualize individual training runs
    or comparisons between runs.

-   No changes to source code required.

## Installation

The R package provides an interface to [Guild AI
Core](https://guild.ai/). The R package will automatically download and
install Guild AI Core on first use, or you can call `install_guild()`
directly to customize the installation. You can install the **guildai**
package as follows:

``` r
# install.packages("guildai")
remotes::install_github("t-kalinowski/guildai-r")
guildai::install_guild()
```

Guild AI can be used with any machine learning framework, or even no
framework at all. For this introductory example, we'll start with a
Keras model applied to the fashion mnist dataset.

If you've not used Keras from R before and you want to follow along on
your machine, you can install it like this:

``` r
install.packages("keras")
keras::install_keras()
```

## Hello World

### Launch a run

```{r include=FALSE, copy-fashion-mnist}
readLines("inst/examples/fashion-mnist.R") %>%
  c("#| sourcecode: {select: [train.R]}", .) %>%
  writeLines("train.R")
```

To start, we'll use an example training script,
["train.R"](https://github.com/t-kalinowski/guildai-r/blob/main/inst/examples/fashion-mnist.R).
Here is what it looks like:

```{r}
#| file: !expr "'train.R'"
#| eval: false
```

To train a model with guildai, use the `guild_run()` function in place
of the `source()` function to execute your R script. For example:

```{r}
guild_run("train.R")
```

This will launch a new R process in an isolated run directory using the
provided script. By default, the output stream from the run will be
shown at the R console (the same output stream you would see with
`source("train.R", echo = TRUE)` or `R --file=train.R`).

### View Runs

Call `guild_view()` to launch the *Guild View* application, which you
can use to visualize and manage your runs. You can use it to search,
filter, visualize, compare, view diffs of run source code and output,
and more! It also bundles TensorBoard as an additional visualization
tool for viewing runs.

``` r
guild_view()
```

TODO: SCREENSHOTS

Retrieve a data frame with run information in R using `ls_runs()`:

```{r}
run <- ls_runs()
tibble::glimpse(run)
```

`ls_runs()` returns a data frame with information about runs. In this
introduction so far, we've only launched 1 run, so so `ls_runs()`
returns a 1-row data frame.

### Run Directories

`guild_view()` and `ls_runs()` provide two convenient ways to gather and
present the information from runs. Importantly however, the run
directory is easily accessible. There you'll find any files, plots,
logs, or other output generated by a run. The run directory also
contains additional metadata about the runs that guild recorded, like
the starting random seed, environment variables, information about the
package versions, and other metadata frequently useful for
reproducability.

```{r}
fs::dir_tree(run$dir[1], all = TRUE)
```

### Comparing Runs

Let's make a couple of changes to our training script to see if we can
improve model performance. We'll change the number of units in our first
dense layer to 128, change the `learning_rate` from 0.001 to 0.003 and
run 20 rather than 10 `epochs`. After making these changes to the source
code we re-run the script using `guild_run()` as before:

```{r, include=FALSE}
guildai:::modify_r_file_flags("train.R",
  list(units = 128, learning_rate = 0.003, epochs = 20),
  overwrite = TRUE)
```

```{r results=FALSE}
guild_run("train.R")
```

The individual metrics `test_loss` and `test_accuracy` are visible in
the comparison table in the Guild View application.

```{r restore-fashion-mnist, include = FALSE}
readLines("inst/examples/fashion-mnist.R") %>%
  c("#| sourcecode: {select: [train.R]}", .) %>%
  writeLines("train.R")
```

## Flags

Flags are a form of run inputs, or paramaterization. The action we just
described, of modifying `learning_rate`, `epochs` and `units` values in
the script before launching the second run, can be performed by
`guild_run()` using the *flags* interface.

By default, guild identifies all top-level assignments of scalar
literals in an R script as *run flags* that can be modified per-run.
Flags can be numeric (double, integer), string, boolean, or complex.

In other words, expressions like this in the R script are identified as
flags:

``` r
units <- 64
learning_rate <- 0.001
batch_size <- 32
epochs <- 10
```

See what flags are available in an R script by calling `guild_run()`
with `"--help-op"` (more on this syntax later).

```{r}
guild_run("train.R", "--help-op")
```

You can launch a run with different flag values like this:

```{r, eval=FALSE}
guild_run("train.R", flags = list(
  learning_rate = 0.001,
  units = 256
))
```

Now, when we inspect the run sources with `view_runs_diff()`, we see
that the source file from the last run has updated flag values, as if we
had modified them manually.

The flags interface is useful for hyperparamater optimization. At it's
simplest, you can iterate over the set of flag values you want and pass
them to separate calls of `guild_run()`:

```{r, eval = FALSE}
for (learning_rate in c(0.001, 0.003))
  guild_run("train.R", c(learning_rate = learning_rate))
```

You can also pass multiple values for each flag, and guild will
automatically expand the combinations to a grid search. For example,
this will launch 4 training runs, each run with a unique pairing of flag
values:

```{r, eval = FALSE}
guild_run("train.R",
          flags = list(learning_rate = c(0.001, 0.003),
                       units = c(128, 256)))
```

Another way to launch a batch of runs is to pass a data frame of flags
values, with each row corresponding to a run.

```{r, eval = TRUE}
flags_df <- expand.grid(learning_rate = c(0.001, 0.003),
                        units = c(128, 256))
flags_df
```

```{r, eval = FALSE}
guild_run("train.R", flags = flags_df)
```

### Flag annotations

You can optionally supply additional metadata about individual flags by
placing hashpipe yaml annotations above the flag expression. For
example, we can update our "train.R" script with the following lines:

``` r
#| description: size of first layer.
#| min: 16
#| max: 256
units <- 32

#| description: Activation function to use.
#| choices: [relu, sigmoid, tanh]
activation <- "relu"
```

Now, the flag `description`s and constraints will appear in `--help-op`
and related locations.

### Flag destinations

As a project grows, it can be helpful to be able to move flag
definitions out of the main R script. To do so, you can include a
`flags-dest` in the frontmatter of the R script, specifying the file
where guild should read and update the flag values. Then you can read in
the flag values in the main R script using `source()` or similar.

    #| flags-dest: ./flags.R

    FLAGS <- envir::include("flags.R", new.env())

YAML files are also supported as a flags destination:

    #| flags-dest: ./flags.yml

    FLAGS <- yaml::read_yaml("flags.yml")

### Retreiving Run Flags

The flags and flag values associated with each runs are returned by
`ls_runs()` as a packed dataframe under the `flags` name.

```{r paged.print=FALSE}
runs <- ls_runs()
runs %>%
  select(id, flags)
```

## Scalars

The counterpart to run `flags` are run `scalars`. Whereas `flags` are a
a special type of run input that guild can help manage, scalars are
special type of run output that guild can help manage.

```{r paged.print=FALSE}
runs %>%
  select(id, scalars)

glimpse(runs$scalars[[1]])
```

Here we see that guild has automatically identified `test_accuracy` and
`test_loss` as run scalar outputs. By default, any lines printed to
standard output during the run with the pattern `"key: <numeric-value>"`
are recorded by guild as `scalars`. If you are printing values for the
same scalar `key` multiple times during a run (e.g, `loss` during a
training loop), then be sure to also print a `step` scalar in between,
to enable guild to track history (and enable visualization of the run
metrics with Guild View and TensorBoard).

If the run process produces tfevent records (e.g.,
`keras::callback_tensorboard()`), those are also automatically
identified by guild as run scalars, and included in `ls_runs()` (and
`guild_view()`, and TensorBoard and other run views).

`ls_runs()` returns the last observed value for each run scalar key, but
the full history of scalars observed in runs can also be accessed from R
directly:

```{r, paged.print=FALSE}
ls_scalars()
```

## Managing runs

Guild comes with a family of functions for managing runs.

-   Annotate runs: `runs_comment()`, `runs_mark()` and `runs_tag()`.
-   Move, archive, or copy runs: `runs_export()` and `runs_import()`.
-   Delete runs: `runs_delete()` `runs_purge()` `runs_restore()`.

The `runs_*` family of functions all take `runs` as a first argument,
and can be composed with `%>%` and `ls_runs()` or `ls_scalars()`. For
example:

```{r paged.print=FALSE}
library(dplyr)

best <- ls_scalars() %>%
  filter(tag == "test_accuracy") %>%
  slice_max(value)

best

best %>%
  runs_tag("best") %>%
  runs_export("./best-runs")
```

```{r, include = FALSE}
unlink("./best-runs", recursive = TRUE)
```

The `runs` arguments can be supplied as data frame, as returned by
`ls_runs()` or `ls_scalars()`, like in the example above. `runs` can
also be a character vector, with a flexible syntax supported for
specifying runs selections: For example, `runs` can be an `id`, an
integer (the n-th last run), or any combination of filter specifications
like `--running` and `--started 'last hour'`. See
`resolve_run_ids("--help")` for details.

## Supplying guild options

<https://my.guild.ai/t/user-config-reference/173>

Guild options can be supplied as hashpipe yaml in the frontmatter of the
script. For example, we can inform guild that the script operation
should not store csv files from the project as part of the run directory
by modifying the front of the script like this:

``` r
#| flags-dest: ./flags.R
#| sourcecode:
#|   - exclude: '*.csv'
```

A comprehensive listing of all the options that can be supplied to guild
via script frontmatter can be found
[here](https://my.guild.ai/t/guild-file-reference/197#operation-attributes-6).

## Using guild from the terminal

`guild` can also be used directly from the terminal. Call the R function
`export_guild_cli()` to place the `guild` executable installed by
`guildai::install_guild()` on your PATH:

``` r
export_guild_cli(dest = "~/bin")
```

Then you can launch runs and perform other guild operations from the
terminal:

``` bash
guild run train.R
guild run train.R batch_size='[32,64]'
```

As you move between the terminal and the R console, almost all of the
same syntax supported from the terminal can be used from R by passing
strings to the respective R functions.

By default, R character vectors supplied to `...` throughout most R
functions are quoted for the system shell and passed through to guild.
This enables usage like:

``` r
guild_run("train.R", "batch_size=[32,64]")
```

There are some additional conveniences provided for passing through
command line options from R.

-   Use `I()` to avoid quoting a string for the shell, allowing you to
    pass through multiple arguments in a single string.
-   For arguments that take values, you can pass them from R as named
    arguments or named objects.
-   Named arguments are automatically translated from R conventions to
    shell conventions:
    -   `_` in a argument name is converted to `-`, and a `--` prefix is
        automatically added, so `batch_comment = "foo"` becomes
        `--batch_comment 'foo'`.
    -   boolean values are understood to be switches, so
        `keep_run = TRUE` is translated to `--keep-run`.
    -   names vectors are automatically recycled for the shell, so
        `tag = c("a", "b" "c")` becomes `--tag a --tag b --tag c`.

Here are a few different R expressions that invoke `guild` with
identical system calls.

``` r
ls_runs(marked = TRUE, started = 'last hour')

ls_runs("--marked", "--started" = "last hour")
ls_runs("--marked", c("--started", "last hour"))
ls_runs("--marked", c("--started" = "last hour"))
ls_runs(c("--marked", "--started", "last hour"))
ls_runs(I("--marked --started 'last hour'"))
ls_runs(I("-Fm -Fs 'last hour'"))
ls_runs(.Fm = TRUE, .Fs = 'last hour')
ls_runs("-Fm", "-Fs" = "last hour")
```

## End to End Example

To tie things together, we'll use guild to explore what impact `units`
has on `test_accuracy` in our training script.

```{r}
units <- (2 ^ (4:11)) %>% c(diff(., 2)) %>% sort()
units
```

```{r }
#| output: false
guildai::guild_run("train.R",
                   flags = list(units = units))
```

We can see compare run flags and run scalars from R:

```{r paged.print=FALSE}
runs <- ls_runs(seq_along(units))

df <- runs %>%
  select(flags, scalars)

df
```

```{r, message=FALSE, warning=FALSE}
library(ggplot2)
ggplot(df, aes(x = flags$units,
               y = scalars$test_accuracy)) +
  geom_point() + geom_smooth()
```

```{r, include = FALSE}
unlink("train.R")
```

### Addin

The **guildai** package installs an RStudio IDE addin which provides
quick access to frequently used functions from the Addins menu:

Note that you can use **Tools** -\> **Modify Keyboard Shortcuts** within
RStudio to assign a keyboard shortcut to one or more of the addin
commands.

### Background Training

Since training runs can become quite lengthy, it's often useful to run
them in the background in order to keep the R console free for other
work. You can launch a guild run without blocking the R console by
specifying `guild_run(background = TRUE)` in the call. You can then view
real-time outputs from your run(s) using `guild_view()`.

Alternatively, you can launch training runs in the terminal pane:

    Rscript -e 'guildai::guild_run("train.R")'

If you are not running within RStudio then you can of course use a
system terminal window for background training.
